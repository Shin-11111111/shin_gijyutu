<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚ã¿ã ãã˜</title>
    <!-- Tailwind CSSã‚’èª­ã¿è¾¼ã‚€ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Interãƒ•ã‚©ãƒ³ãƒˆã‚’ä½¿ç”¨ -->
    <style>
        /* ç”»é¢å…¨ä½“ã‚’ä½¿ç”¨ã—ã€ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’åˆ¶å¾¡ã™ã‚‹ãŸã‚ã®è¨­å®š */
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #f3f4f6; 
            margin: 0;
            padding: 0;
            overflow: hidden; /* bodyå…¨ä½“ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç¦æ­¢ */
        }
        
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh; /* ç”»é¢ã®é«˜ã•ã«å›ºå®š */
            padding: 1rem 1.5rem; 
        }

        /* ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ãƒƒãƒ‘ãƒ¼ãŒæ®‹ã‚Šã®é«˜ã•ã‚’å æœ‰ã—ã€å…¨ä½“ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’æŠ‘ãˆã‚‹ */
        .content-wrapper {
            flex-grow: 1; /* ä¿®æ­£: flex-grow = 1 -> flex-grow: 1 */
            overflow: hidden; /* å­è¦ç´ ãŒã¯ã¿å‡ºã•ãªã„ã‚ˆã†ã«ã‚¯ãƒªãƒƒãƒ— */
        }
        
        /* ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã§å·¦å³é…ç½®ã™ã‚‹ãŸã‚ã®Flexè¨­å®š */
        @media (min-width: 768px) {
            .content-wrapper {
                flex-direction: row;
            }
            /* å·¦å´ã®è¨­å®šãƒ‘ãƒãƒ«: æœ€å¤§å¹…ã‚’åˆ¶é™ã—ã€ç¸¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’è¨±å¯ */
            .settings-panel {
                max-width: 350px; 
                height: 100%;
                overflow-y: auto; /* è¨­å®šãƒ‘ãƒãƒ«å†…ã®ã¿ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯èƒ½ */
            }
            /* å³å´ã®æç”»ã‚¨ãƒªã‚¢: æ®‹ã‚Šã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’åŸ‹ã‚ã€ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢ */
            .amida-display {
                flex-grow: 1; /* ä¿®æ­£: flex-grow = 1 -> flex-grow: 1 */
                overflow: hidden; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢ */
                display: flex;
                flex-direction: column;
                justify-content: center; /* å‚ç›´æ–¹å‘ä¸­å¤®å¯„ã› */
                align-items: center; /* æ°´å¹³æ–¹å‘ä¸­å¤®å¯„ã› */
            }
            /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚³ãƒ³ãƒ†ãƒŠã®å¹…ã¨é«˜ã•ã‚’åˆ¶é™ */
            .canvas-container {
                max-width: 100%;
                max-height: 100%;
            }
        }

        .canvas-container { 
            position: relative; 
            width: 100%; 
            max-width: 600px; /* PCç”»é¢ã§ã®æœ€å¤§å¹…ã‚’ç¶­æŒ */
            margin: 0 auto; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); 
        }
        canvas { display: block; border-radius: 0.75rem; background-color: #ffffff; }
    </style>
</head>
<body>

<div class="main-container">
    <h1 class="text-3xl font-bold text-center mb-4 text-gray-800 flex-shrink-0">ã‚ã¿ã ãã˜</h1>
    
    <!-- è¨­å®šãƒ‘ãƒãƒ«ã¨æç”»ã‚¨ãƒªã‚¢ã‚’å›²ã‚€ã‚³ãƒ³ãƒ†ãƒŠ (md:flex-rowã§å·¦å³é…ç½®) -->
    <div class="content-wrapper flex flex-col md:flex-row gap-6">

        <!-- å·¦: è¨­å®šãƒ‘ãƒãƒ« (ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯èƒ½) -->
        <div class="settings-panel bg-white p-4 rounded-xl shadow-lg md:mb-0 mb-6 flex-shrink-0">
            <h2 class="text-xl font-semibold mb-3 text-indigo-600">è¨­å®š</h2>

            <!-- é¸æŠè‚¢ï¼ˆåˆ—ï¼‰ã®æ•° -->
            <div class="mb-4">
                <label for="columnCount" class="block text-sm font-medium text-gray-700 mb-1">é¸æŠè‚¢ï¼ˆåˆ—ï¼‰ã®æ•° (3ã€œ10)</label>
                <input type="number" id="columnCount" value="5" min="3" max="10"
                       class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150">
            </div>

            <!-- ã‚´ãƒ¼ãƒ«ï¼ˆçµæœï¼‰ã®å…¥åŠ› -->
            <div id="goalInputs" class="mb-4 space-y-2">
                <label class="block text-sm font-medium text-gray-700 mb-1">ã‚´ãƒ¼ãƒ«çµæœ (5å€‹)</label>
                <!-- ã‚´ãƒ¼ãƒ«å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã“ã“ã«å‹•çš„ã«æŒ¿å…¥ã•ã‚Œã¾ã™ -->
            </div>
            
            <!-- ã‚¹ã‚¿ãƒ¼ãƒˆï¼ˆé …ç›®ï¼‰ã®å…¥åŠ› -->
            <div id="startInputs" class="mb-4 space-y-2">
                <label class="block text-sm font-medium text-gray-700 mb-1">ã‚¹ã‚¿ãƒ¼ãƒˆã®é¸æŠ (5å€‹)</label>
                <!-- ã‚¹ã‚¿ãƒ¼ãƒˆå…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã“ã“ã«å‹•çš„ã«æŒ¿å…¥ã•ã‚Œã¾ã™ -->
            </div>

            <button id="generateButton"
                    class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 ease-in-out transform hover:scale-105 shadow-md mt-2">
                ã‚ã¿ã ã‚’ç”Ÿæˆ / ãƒªã‚»ãƒƒãƒˆ
            </button>
            <!-- ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã®ãƒ€ãƒŸãƒ¼ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ -->
            <div class="h-6 mt-4 text-gray-400 text-xs md:hidden">ï¼ˆãƒ¢ãƒã‚¤ãƒ«ã§ã¯ã“ã“ã«è¨­å®šãƒ‘ãƒãƒ«ã®çµ‚ç‚¹ãŒã‚ã‚Šã¾ã™ï¼‰</div>
            <div class="mt-4 p-2 bg-gray-50 rounded-lg text-sm text-gray-600 hidden md:block">
                <p class="font-semibold mb-1">ğŸ’¡ ãƒ’ãƒ³ãƒˆ:</p>
                <p>ã‚ã¿ã ãã˜ã®ç·šãŒãªã„å ´æ‰€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚‚ã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¯å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“ã€‚</p>
            </div>
        </div>
        
        <!-- å³: ã‚ã¿ã ãã˜æç”»ã‚¨ãƒªã‚¢ (ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢) -->
        <div class="amida-display">
            <div class="canvas-container">
                <canvas id="amidaCanvas"></canvas>
                <div id="messageBox" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 text-white text-xl font-bold rounded-xl hidden p-4">
                    <!-- çµæœãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ -->
                </div>
            </div>
            
            <!-- èª¬æ˜ -->
            <p class="text-center text-gray-500 text-sm mt-4 flex-shrink-0">ä¸Šã®ã‚¹ã‚¿ãƒ¼ãƒˆã€ã¾ãŸã¯ä¸‹ã®ã‚´ãƒ¼ãƒ«ã®æ–‡å­—ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã€ã‚ã¿ã ãã˜ã®çµæœã‚’ç¢ºèªã§ãã¾ã™ã€‚</p>
        </div>
        
    </div>
</div>

<script type="module">
    // å®šæ•°
    const CANVAS_WIDTH = 600;
    const CANVAS_HEIGHT = 800;
    const MARGIN_X = 50;
    const MARGIN_Y = 100;
    const RUNG_COUNT = 15; // ç¸¦ç·šä¸€æœ¬ã‚ãŸã‚Šã®æ¨ªç·šã®æ•°ï¼ˆãƒ©ãƒ³ãƒ€ãƒ é…ç½®ï¼‰
    const ANIMATION_DURATION = 2500; // 2.5ç§’
    const HORIZONTAL_STEP_COUNT = 10; // æ¨ªç§»å‹•ã‚’åˆ†å‰²ã™ã‚‹ã‚¹ãƒ†ãƒƒãƒ—æ•°

    // DOMè¦ç´ 
    const canvas = document.getElementById('amidaCanvas');
    const ctx = canvas.getContext('2d');
    const columnCountInput = document.getElementById('columnCount');
    const goalInputsContainer = document.getElementById('goalInputs');
    const startInputsContainer = document.getElementById('startInputs');
    const messageBox = document.getElementById('messageBox');
    const generateButton = document.getElementById('generateButton');
    const canvasContainer = document.querySelector('.canvas-container');
    const amidaDisplay = document.querySelector('.amida-display'); 

    // State (çŠ¶æ…‹ç®¡ç†)
    let numColumns = 5;
    let rungs = []; // æ¨ªç·šã®æƒ…å ±: [{col: 0, y: 100}, ...]
    let startLabels = ['ãƒ¦ãƒ¼ã‚¶ãƒ¼ 1', 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ 2', 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ 3', 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ 4', 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ 5'];
    let goalLabels = ['å½“ãŸã‚Š', 'ãƒã‚ºãƒ¬', 'ãƒã‚ºãƒ¬', 'ãƒã‚ºãƒ¬', 'ãƒã‚ºãƒ¬'];
    let columnPositions = [];

    // Animation states
    let animationFrameId = null; // requestAnimationFrame ID
    let pathCoordinates = []; // çµŒè·¯å…¨ä½“ã®åº§æ¨™ãƒ‡ãƒ¼ã‚¿ [{x: ..., y: ...}, ...]
    let animationStartTime = null; // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹æ™‚é–“
    let currentTrace = {
        from: null, // 'start' or 'goal'
        startCol: -1, 
        endCol: -1 
    };

    /**
     * ã‚­ãƒ£ãƒ³ãƒã‚¹ã®åˆæœŸè¨­å®šã¨ãƒªã‚µã‚¤ã‚ºå‡¦ç†
     */
    function setupCanvas() {
        // æç”»è§£åƒåº¦ã‚’è¨­å®š
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        
        // ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œã®ãŸã‚ã«CSSã‚µã‚¤ã‚ºã‚’è¨­å®š
        const resize = () => {
            const containerWidth = amidaDisplay.clientWidth;
            const containerHeight = amidaDisplay.clientHeight; 
            
            const aspectRatio = CANVAS_HEIGHT / CANVAS_WIDTH;

            let cssWidth;
            let cssHeight;

            const heightBasedOnWidth = containerWidth * aspectRatio;
            
            if (heightBasedOnWidth <= containerHeight) {
                // å¹…åŸºæº–ã§è¨ˆç®—ã—ãŸé«˜ã•ãŒã‚³ãƒ³ãƒ†ãƒŠã®é«˜ã•ã‚’è¶…ãˆãªã„å ´åˆ
                cssWidth = containerWidth;
                cssHeight = heightBasedOnWidth;
            } else {
                // å¹…åŸºæº–ã§è¨ˆç®—ã—ãŸé«˜ã•ãŒã‚³ãƒ³ãƒ†ãƒŠã®é«˜ã•ã‚’è¶…ãˆã‚‹å ´åˆ (é«˜ã•ã«åˆã‚ã›ã‚‹)
                cssHeight = containerHeight;
                cssWidth = containerHeight / aspectRatio;
            }

            // æœ€å¤§ã‚µã‚¤ã‚ºã¯ã€ä¸­å¤®é…ç½®ã•ã‚ŒãŸã‚­ãƒ£ãƒ³ãƒã‚¹ã‚³ãƒ³ãƒ†ãƒŠã®è¦ªè¦ç´ ï¼ˆamida-displayï¼‰ã®80%ç¨‹åº¦ã«åˆ¶é™ã—ã€
            // è¨­å®šãƒ‘ãƒãƒ«ã¨ã®ãƒãƒ©ãƒ³ã‚¹ã‚’å–ã‚‹ã€‚ãŸã ã—ã€ã“ã“ã§ã¯100%ã‚’ç¶­æŒã—ã€CSSã§åˆ¶ç´„ã—ã¦ã„ã‚‹ã€‚
            
            // CSSã‚µã‚¤ã‚ºã‚’é©ç”¨
            canvas.style.width = cssWidth + 'px';
            canvas.style.height = cssHeight + 'px';
            
            canvasContainer.style.width = cssWidth + 'px';
            canvasContainer.style.height = cssHeight + 'px';
        };
        
        window.addEventListener('resize', resize);
        resize();
        
        updateLadder();
    }

    /**
     * ã‚´ãƒ¼ãƒ«ã¨ã‚¹ã‚¿ãƒ¼ãƒˆã®å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å‹•çš„ã«ç”Ÿæˆã—ã¾ã™ã€‚
     */
    function generateDynamicInputs() {
        const count = parseInt(columnCountInput.value);
        if (isNaN(count) || count < 3 || count > 10) return;
        numColumns = count;

        // ã‚´ãƒ¼ãƒ«å…¥åŠ›ã®ç”Ÿæˆ
        goalInputsContainer.querySelector('label').textContent = `ã‚´ãƒ¼ãƒ«çµæœ (${numColumns}å€‹)`;
        // ç¾åœ¨ã®å€¤ã‚’ä¿æŒã—ãªãŒã‚‰æ–°ã—ã„å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ç”Ÿæˆ
        const currentGoalLabels = Array.from(goalInputsContainer.querySelectorAll('input')).map(input => input.value);
        goalLabels = currentGoalLabels.slice(0, numColumns);
        
        const newGoalInputsHTML = Array(numColumns).fill(0).map((_, i) => {
            const val = goalLabels[i] || (i < currentGoalLabels.length ? currentGoalLabels[i] : `ã‚´ãƒ¼ãƒ« ${i + 1}`);
            return `<input type="text" id="goalInput${i}" value="${val}" placeholder="ã‚´ãƒ¼ãƒ« ${i + 1}"
                       class="w-full p-2 border border-gray-300 rounded-lg text-sm transition duration-150">`;
        }).join('');
        Array.from(goalInputsContainer.children).filter(el => el.tagName !== 'LABEL').forEach(el => el.remove());
        goalInputsContainer.insertAdjacentHTML('beforeend', newGoalInputsHTML);


        // ã‚¹ã‚¿ãƒ¼ãƒˆå…¥åŠ›ã®ç”Ÿæˆ
        startInputsContainer.querySelector('label').textContent = `ã‚¹ã‚¿ãƒ¼ãƒˆã®é¸æŠ (${numColumns}å€‹)`;
        // ç¾åœ¨ã®å€¤ã‚’ä¿æŒã—ãªãŒã‚‰æ–°ã—ã„å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ç”Ÿæˆ
        const currentStartLabels = Array.from(startInputsContainer.querySelectorAll('input')).map(input => input.value);
        startLabels = currentStartLabels.slice(0, numColumns);

        const newStartInputsHTML = Array(numColumns).fill(0).map((_, i) => {
            const val = startLabels[i] || (i < currentStartLabels.length ? currentStartLabels[i] : `ãƒ¦ãƒ¼ã‚¶ãƒ¼ ${i + 1}`);
            return `<input type="text" id="startInput${i}" value="${val}" placeholder="ã‚¹ã‚¿ãƒ¼ãƒˆ ${i + 1}"
                       class="w-full p-2 border border-gray-300 rounded-lg text-sm transition duration-150">`;
        }).join('');
        Array.from(startInputsContainer.children).filter(el => el.tagName !== 'LABEL').forEach(el => el.remove());
        startInputsContainer.insertAdjacentHTML('beforeend', newStartInputsHTML);
    }

    /**
     * å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰æœ€æ–°ã®ãƒ©ãƒ™ãƒ«ã‚’å–å¾—ã—ã¦Stateã‚’æ›´æ–°ã—ã¾ã™ã€‚
     */
    function updateLabelsFromInputs() {
        startLabels = [];
        goalLabels = [];
        for (let i = 0; i < numColumns; i++) {
            const startInput = document.getElementById(`startInput${i}`);
            const goalInput = document.getElementById(`goalInput${i}`);
            
            startLabels.push(startInput ? startInput.value.trim() || `ãƒ¦ãƒ¼ã‚¶ãƒ¼ ${i + 1}` : `ãƒ¦ãƒ¼ã‚¶ãƒ¼ ${i + 1}`);
            goalLabels.push(goalInput ? goalInput.value.trim() || `ã‚´ãƒ¼ãƒ« ${i + 1}` : `ã‚´ãƒ¼ãƒ« ${i + 1}`);
        }
    }

    /**
     * ã‚ã¿ã ãã˜ã®æ¨ªç·šï¼ˆRungsï¼‰ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«ç”Ÿæˆã—ã¾ã™ã€‚
     */
    function generateRungs() {
        rungs = [];
        const rungHeight = (CANVAS_HEIGHT - 2 * MARGIN_Y) / RUNG_COUNT;
        
        const rungsMap = Array(numColumns - 1).fill(0).map(() => Array(RUNG_COUNT).fill(false));

        for (let col = 0; col < numColumns - 1; col++) {
            for (let i = 0; i < RUNG_COUNT; i++) {
                if (Math.random() < 0.5) {
                    if (col > 0 && rungsMap[col - 1][i]) {
                        continue; // éš£æ¥ã™ã‚‹æ¨ªç·šãŒã™ã§ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                    }
                    rungsMap[col][i] = true;
                    const y = MARGIN_Y + (i + 0.5) * rungHeight; 
                    rungs.push({ col, y });
                }
            }
        }
    }

    /**
     * ã‚ã¿ã ãã˜ã®é™çš„ãªéƒ¨åˆ†ï¼ˆç¸¦ç·šã€æ¨ªç·šã€ãƒ©ãƒ™ãƒ«ï¼‰ã‚’æç”»ã—ã¾ã™ã€‚
     */
    function drawStaticLadder() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        const availableWidth = CANVAS_WIDTH - 2 * MARGIN_X;
        const columnSpacing = availableWidth / (numColumns - 1);
        columnPositions = [];

        // 1. ç¸¦ç·šã¨ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚´ãƒ¼ãƒ«ãƒ©ãƒ™ãƒ«ã®æç”»
        for (let i = 0; i < numColumns; i++) {
            const x = MARGIN_X + i * columnSpacing;
            columnPositions.push(x);

            // ç¸¦ç·š
            ctx.beginPath();
            ctx.moveTo(x, MARGIN_Y);
            ctx.lineTo(x, CANVAS_HEIGHT - MARGIN_Y);
            ctx.strokeStyle = '#9ca3af'; // Gray-400
            ctx.lineWidth = 4;
            ctx.stroke();

            // ã‚¹ã‚¿ãƒ¼ãƒˆãƒ©ãƒ™ãƒ« (ä¸Šéƒ¨)
            ctx.textAlign = 'center';
            ctx.font = '20px Inter, sans-serif';
            ctx.fillStyle = '#1f2937'; // Gray-800
            ctx.fillText(startLabels[i], x, MARGIN_Y - 30);
            
            // ã‚´ãƒ¼ãƒ«ãƒ©ãƒ™ãƒ« (ä¸‹éƒ¨)
            ctx.font = '18px Inter, sans-serif';
            ctx.fillStyle = '#10b981'; // Emerald-500
            ctx.fillText(goalLabels[i], x, CANVAS_HEIGHT - MARGIN_Y + 40);
        }

        // 2. æ¨ªç·šã®æç”»
        rungs.forEach(rung => {
            const x1 = columnPositions[rung.col];
            const x2 = columnPositions[rung.col + 1];
            
            ctx.beginPath();
            ctx.moveTo(x1, rung.y);
            ctx.lineTo(x2, rung.y);
            ctx.strokeStyle = '#3b82f6'; // Blue-500
            ctx.lineWidth = 4;
            ctx.stroke();
        });
    }

    /**
     * ã‚ã¿ã ãã˜å…¨ä½“ã‚’æç”»ã—ã¾ã™ã€‚ï¼ˆé™çš„ãªéƒ¨åˆ†ã®ã¿ã‚’æç”»ã—ã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã§ãªã„å ´åˆã¯æœ€çµ‚ãƒ‘ã‚¹ã‚’æç”»ï¼‰
     */
    function drawLadder() {
        drawStaticLadder();
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒåœæ­¢ã—ã¦ã„ã¦ã€ã‹ã¤ä¸€åº¦ãƒˆãƒ¬ãƒ¼ã‚¹ãŒå®Œäº†ã—ã¦ã„ã‚‹å ´åˆã¯ã€æœ€çµ‚çµæœãƒ‘ã‚¹ã‚’æç”»ã™ã‚‹
        if (animationFrameId === null && pathCoordinates.length > 0) {
            drawInstantPath(pathCoordinates);
        }
    }

    /**
     * ã‚ã¿ã ãã˜ã®è»Œè·¡ï¼ˆPathï¼‰ã‚’è¨ˆç®—ã—ã€çµæœã®åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨è©³ç´°ãªçµŒè·¯åº§æ¨™ã‚’è¿”ã—ã¾ã™ã€‚ï¼ˆé †æ–¹å‘ï¼šä¸Šã‹ã‚‰ä¸‹ï¼‰
     */
    function calculatePathForward(startCol) {
        let path = [];
        let currentCol = startCol;
        let y = MARGIN_Y;
        const endY = CANVAS_HEIGHT - MARGIN_Y;
        const V_STEP = 5; 
        const rungHitTolerance = 5;

        path.push({ x: columnPositions[currentCol], y: y, startCol: startCol, finalCol: -1 });

        let remainingRungs = Array.from(rungs).sort((a, b) => a.y - b.y);

        while (y < endY) {
            y += V_STEP;
            if (y > endY) y = endY;

            let nextRungIndex = -1;

            // 1. æ¨ªç·šã«ã¶ã¤ã‹ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            for (let i = 0; i < remainingRungs.length; i++) {
                const rung = remainingRungs[i];
                const isConnected = (rung.col === currentCol) || (rung.col + 1 === currentCol);
                
                if (isConnected && rung.y > y - V_STEP && rung.y <= y + rungHitTolerance) { 
                    nextRungIndex = i;
                    break;
                }
            }

            if (nextRungIndex !== -1) {
                const nextRung = remainingRungs[nextRungIndex];
                const rungY = nextRung.y;

                y = rungY;
                path.push({ x: columnPositions[currentCol], y: y }); // æ¨ªç·šæ‰‹å‰ã®åº§æ¨™ã‚’è¨˜éŒ²

                let targetCol;
                if (nextRung.col === currentCol) {
                    targetCol = currentCol + 1; // å³ã¸ç§»å‹•
                } else {
                    targetCol = currentCol - 1; // å·¦ã¸ç§»å‹•
                }

                const x1 = columnPositions[currentCol];
                const x2 = columnPositions[targetCol];
                const dx = x2 - x1;
                
                // 2. æ¨ªç§»å‹•ã‚’åˆ†å‰²ã—ã¦çµŒè·¯ã«è¨˜éŒ²
                for (let i = 1; i <= HORIZONTAL_STEP_COUNT; i++) {
                    const stepX = x1 + dx * (i / HORIZONTAL_STEP_COUNT);
                    path.push({ x: stepX, y: rungY });
                }

                currentCol = targetCol;
                remainingRungs.splice(nextRungIndex, 1);
                
                y += 1; 
            }
            
            path.push({ x: columnPositions[currentCol], y: y }); // ç¸¦ç·šä¸Šã®åº§æ¨™ã‚’è¨˜éŒ²
        }
        
        path[path.length - 1].finalCol = currentCol;
        return { finalCol: currentCol, path: path };
    }
    
    /**
     * ã‚ã¿ã ãã˜ã®è»Œè·¡ï¼ˆPathï¼‰ã‚’è¨ˆç®—ã—ã€çµæœã®åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨è©³ç´°ãªçµŒè·¯åº§æ¨™ã‚’è¿”ã—ã¾ã™ã€‚ï¼ˆé€†æ–¹å‘ï¼šä¸‹ã‹ã‚‰ä¸Šï¼‰
     * @param {number} endCol 0ã‹ã‚‰å§‹ã¾ã‚‹çµ‚äº†åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
     * @returns {{startCol: number, path: Array<{x: number, y: number}>}}
     */
    function calculatePathBackward(endCol) {
        let path = [];
        let currentCol = endCol;
        let y = CANVAS_HEIGHT - MARGIN_Y;
        const startY = MARGIN_Y;
        const V_STEP = 5; 
        const rungHitTolerance = 5;

        // æœ€åˆã®ç‚¹ (ã‚´ãƒ¼ãƒ«åœ°ç‚¹)
        path.push({ x: columnPositions[currentCol], y: y, startCol: -1, finalCol: endCol });

        // Yåº§æ¨™ã§é™é †ã«ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸæ®‹ã‚Šã®æ¨ªç·šãƒªã‚¹ãƒˆ
        let remainingRungs = Array.from(rungs).sort((a, b) => b.y - a.y); 

        while (y > startY) {
            y -= V_STEP;
            if (y < startY) y = startY;

            let nextRungIndex = -1;

            // 1. æ¨ªç·šã«ã¶ã¤ã‹ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            for (let i = 0; i < remainingRungs.length; i++) {
                const rung = remainingRungs[i];
                const isConnected = (rung.col === currentCol) || (rung.col + 1 === currentCol);

                // ä¸Šå‘ãã«ç§»å‹•ä¸­ã«æ¨ªç·šã«åˆ°é”ã—ãŸã‹
                if (isConnected && rung.y < y + V_STEP && rung.y >= y - rungHitTolerance) {
                    nextRungIndex = i;
                    break;
                }
            }

            if (nextRungIndex !== -1) {
                const nextRung = remainingRungs[nextRungIndex];
                const rungY = nextRung.y;

                y = rungY;
                path.push({ x: columnPositions[currentCol], y: y }); // æ¨ªç·šæ‰‹å‰ã®åº§æ¨™ã‚’è¨˜éŒ²

                let targetCol;
                if (nextRung.col === currentCol) {
                    targetCol = currentCol + 1; // å³ã«ã‚ã£ãŸç¸¦ç·šã¸ç§»å‹•
                } else {
                    targetCol = currentCol - 1; // å·¦ã«ã‚ã£ãŸç¸¦ç·šã¸ç§»å‹•
                }
                
                const x1 = columnPositions[currentCol];
                const x2 = columnPositions[targetCol];
                const dx = x2 - x1;

                // 2. æ¨ªç§»å‹•ã‚’åˆ†å‰²ã—ã¦çµŒè·¯ã«è¨˜éŒ² (ä¸‹ã‹ã‚‰ä¸Šãªã®ã§ã€Xåº§æ¨™ã¯ x1 ã‹ã‚‰ x2 ã¸å‘ã‹ã†)
                for (let i = 1; i <= HORIZONTAL_STEP_COUNT; i++) {
                    const stepX = x1 + dx * (i / HORIZONTAL_STEP_COUNT);
                    path.push({ x: stepX, y: rungY });
                }

                currentCol = targetCol;
                remainingRungs.splice(nextRungIndex, 1);
                
                y -= 1; 
            }
            
            path.push({ x: columnPositions[currentCol], y: y }); // ç¸¦ç·šä¸Šã®åº§æ¨™ã‚’è¨˜éŒ²
        }
        
        path[path.length - 1].startCol = currentCol;
        
        // é…åˆ—ã¯ã€Œåº• -> é ‚ã€ã®é †ã§æ§‹ç¯‰ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ã“ã®ã¾ã¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°ã«æ¸¡ã™
        return { startCol: currentCol, path: path }; 
    }


    /**
     * çµŒè·¯åº§æ¨™ã‚’ç¬æ™‚ã«æç”»ã—ã¾ã™ã€‚ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†å¾Œã®æœ€çµ‚è¡¨ç¤ºã«ä½¿ç”¨ï¼‰
     */
    function drawInstantPath(path) {
        if (path.length === 0) return;

        ctx.strokeStyle = '#ef4444'; // Red-500
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';

        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        for (let i = 1; i < path.length; i++) {
            ctx.lineTo(path[i].x, path[i].y);
        }
        ctx.stroke();

        // çµ‚ç‚¹ã«å††ã‚’æç”»
        const endPoint = path[path.length - 1];
        ctx.fillStyle = '#ef4444'; // Red-500
        ctx.beginPath();
        ctx.arc(endPoint.x, endPoint.y, 8, 0, Math.PI * 2);
        ctx.fill();
    }

    /**
     * ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®çµŒè·¯æç”»é–¢æ•°
     */
    function drawAnimatedPath(pathSegment) {
        if (pathSegment.length === 0) return;

        ctx.strokeStyle = '#ef4444'; 
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';

        ctx.beginPath();
        ctx.moveTo(pathSegment[0].x, pathSegment[0].y);
        for (let i = 1; i < pathSegment.length; i++) {
            ctx.lineTo(pathSegment[i].x, pathSegment[i].y);
        }
        ctx.stroke();
        
        // ç¾åœ¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä½ç½®ã«ç‚¹ã‚’æç”»
        const currentPoint = pathSegment[pathSegment.length - 1];
        ctx.fillStyle = '#ef4444'; 
        ctx.beginPath();
        ctx.arc(currentPoint.x, currentPoint.y, 8, 0, Math.PI * 2);
        ctx.fill();
    }

    /**
     * ã‚ã¿ã ãã˜ã®è»Œè·¡ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
     */
    function animatePath(timestamp) {
        if (!animationStartTime) {
            animationStartTime = timestamp;
        }

        const elapsed = timestamp - animationStartTime;
        const progress = Math.min(elapsed / ANIMATION_DURATION, 1);
        
        const currentPathIndex = Math.floor(progress * (pathCoordinates.length - 1));

        // 1. é™çš„ãªæ¢¯å­ã‚’æç”»ï¼ˆèƒŒæ™¯ï¼‰
        drawStaticLadder();

        // 2. ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã®ãƒ‘ã‚¹ã‚’æç”»
        drawAnimatedPath(pathCoordinates.slice(0, currentPathIndex + 1));

        if (progress < 1) {
            animationFrameId = requestAnimationFrame(animatePath);
        } else {
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†
            cancelAnimation();

            // æœ€çµ‚çµæœè¡¨ç¤º
            // ã‚¹ã‚¿ãƒ¼ãƒˆã‹ã‚‰ã®ãƒˆãƒ¬ãƒ¼ã‚¹ (ä¸Šã‹ã‚‰ä¸‹)
            if (currentTrace.from === 'start') {
                displayResult(currentTrace.startCol, currentTrace.endCol);
            } 
            // ã‚´ãƒ¼ãƒ«ã‹ã‚‰ã®ãƒˆãƒ¬ãƒ¼ã‚¹ (ä¸‹ã‹ã‚‰ä¸Š)
            else if (currentTrace.from === 'goal') {
                displayResult(currentTrace.startCol, currentTrace.endCol);
            }
            
            // æç”»ã‚’ä¸€åº¦æ›´æ–°ã—ã€æœ€çµ‚çš„ãªãƒ‘ã‚¹ã‚’å®Œå…¨ã«è¡¨ç¤ºã™ã‚‹
            drawLadder(); 
        }
    }
    
    /**
     * ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã€çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚
     */
    function cancelAnimation() {
        if (animationFrameId !== null) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        animationStartTime = null;
    }
    
    /**
     * çµæœã‚’ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ã«è¡¨ç¤ºã—ã¾ã™ã€‚
     */
    function displayResult(startCol, endCol) {
        let resultText;
        if (currentTrace.from === 'start') {
            // é †æ–¹å‘ (ã‚¹ã‚¿ãƒ¼ãƒˆ -> ã‚´ãƒ¼ãƒ«)
            resultText = `
                <div class="text-center">
                    <p class="text-3xl mb-2 text-white">${startLabels[startCol]}</p>
                    <p class="text-5xl font-extrabold text-yellow-300">ã®çµæœã¯...</p>
                    <p class="text-6xl mt-4 text-green-400 animate-pulse">${goalLabels[endCol]}</p>
                    <p class="text-xl mt-4 text-gray-200">ã‚‚ã†ä¸€åº¦ã‚¿ãƒƒãƒ—ã—ã¦ãƒªã‚»ãƒƒãƒˆ</p>
                </div>
            `;
        } else if (currentTrace.from === 'goal') {
             // é€†æ–¹å‘ (ã‚´ãƒ¼ãƒ« -> ã‚¹ã‚¿ãƒ¼ãƒˆ)
            resultText = `
                <div class="text-center">
                    <p class="text-3xl mb-2 text-green-400">${goalLabels[endCol]}</p>
                    <p class="text-5xl font-extrabold text-yellow-300">ã«å¯¾å¿œã™ã‚‹ã®ã¯...</p>
                    <p class="text-6xl mt-4 text-white animate-pulse">${startLabels[startCol]}</p>
                    <p class="text-xl mt-4 text-gray-200">ã‚‚ã†ä¸€åº¦ã‚¿ãƒƒãƒ—ã—ã¦ãƒªã‚»ãƒƒãƒˆ</p>
                </div>
            `;
        } else {
            return;
        }
        
        messageBox.innerHTML = resultText;
        messageBox.classList.remove('hidden');
    }


    /**
     * ã‚ã¿ã ãã˜ã‚¨ãƒªã‚¢ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’å‡¦ç†ã—ã¾ã™ã€‚
     */
    function handleCanvasClick(event) {
        
        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯éè¡¨ç¤ºã«ã™ã‚‹ï¼ˆãƒªã‚»ãƒƒãƒˆå‡¦ç†ï¼‰
        if (!messageBox.classList.contains('hidden')) {
            hideMessageBoxAndClearPath();
            return; 
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œä¸­ã¯æ–°ã—ã„ã‚¯ãƒªãƒƒã‚¯ã‚’ç„¡è¦–ã™ã‚‹
        if (animationFrameId !== null) {
             return; 
        }

        // ã‚¯ãƒªãƒƒã‚¯åº§æ¨™ã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã®åº§æ¨™ã«å¤‰æ›
        const rect = canvas.getBoundingClientRect();
        // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã¯e.touches[0]ã‚’ä½¿ç”¨
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;
        const clientY = event.touches ? event.touches[0].clientY : event.clientY;
        
        const scaleX = canvas.width / rect.width;
        const clickX = (clientX - rect.left) * scaleX;
        const clickY = (clientY - rect.top) * scaleX;

        let clickedCol = -1;
        let minDistance = Infinity;

        for (let i = 0; i < numColumns; i++) {
            const colX = columnPositions[i];
            const distance = Math.abs(clickX - colX);

            if (distance < minDistance) {
                minDistance = distance;
                clickedCol = i;
            }
        }

        const isNearColumn = columnPositions.length > 1 ? minDistance < (columnPositions[1] - columnPositions[0]) / 2 : minDistance < MARGIN_X;
        
        if (!isNearColumn) {
            if (pathCoordinates.length > 0) {
                hideMessageBoxAndClearPath();
            }
            return;
        }

        // ----------------------------------------------------
        // 1. ã‚¹ã‚¿ãƒ¼ãƒˆé …ç›®ï¼ˆä¸Šéƒ¨ï¼‰ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸå ´åˆ -> ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹ (ä¸Šã‹ã‚‰ä¸‹)
        // ----------------------------------------------------
        // ã‚¯ãƒªãƒƒã‚¯ç¯„å›²: MARGIN_Y ã®ä¸Šä¸‹50pxä»¥å†…
        if (clickY >= MARGIN_Y - 50 && clickY <= MARGIN_Y + 50) {
            cancelAnimation(); 

            const { finalCol, path } = calculatePathForward(clickedCol);
            
            pathCoordinates = path;
            currentTrace.from = 'start';
            currentTrace.startCol = clickedCol;
            currentTrace.endCol = finalCol;

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
            animationStartTime = null;
            animationFrameId = requestAnimationFrame(animatePath);

        } 
        // ----------------------------------------------------
        // 2. ã‚´ãƒ¼ãƒ«é …ç›®ï¼ˆä¸‹éƒ¨ï¼‰ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸå ´åˆ -> ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹ (ä¸‹ã‹ã‚‰ä¸Š)
        // ----------------------------------------------------
        // ã‚¯ãƒªãƒƒã‚¯ç¯„å›²: CANVAS_HEIGHT - MARGIN_Y ã®ä¸Šä¸‹50pxä»¥å†…
        else if (clickY >= CANVAS_HEIGHT - MARGIN_Y - 50 && clickY <= CANVAS_HEIGHT - MARGIN_Y + 50) {
            cancelAnimation(); 
            
            const { startCol, path } = calculatePathBackward(clickedCol);
            
            pathCoordinates = path;
            currentTrace.from = 'goal';
            currentTrace.startCol = startCol;
            currentTrace.endCol = clickedCol;
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
            animationStartTime = null;
            animationFrameId = requestAnimationFrame(animatePath);
        }
    }
    
    /**
     * ã‚ã¿ã ãã˜ã‚’æ›´æ–°ï¼ˆè¨­å®šå¤‰æ›´æ™‚ï¼‰ã—ã€æç”»ã—ã¾ã™ã€‚
     */
    function updateLadder() {
        hideMessageBoxAndClearPath();
        
        const currentCount = parseInt(columnCountInput.value);
        if (isNaN(currentCount) || currentCount < 3 || currentCount > 10) {
            messageBox.innerHTML = '<p class="text-3xl text-red-500">ã‚¨ãƒ©ãƒ¼: åˆ—æ•°ã¯3ã‹ã‚‰10ã®é–“ã§æŒ‡å®šã—ã¦ãã ã•ã„ã€‚</p>';
            messageBox.classList.remove('hidden');
            return;
        }

        // numColumnsãŒå¤‰æ›´ã•ã‚ŒãŸå¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§ã€ã¾ãšdynamicInputsã‚’æ›´æ–°ã—ã€
        // ãã®å¾Œã§æ–°ã—ã„å…¥åŠ›å€¤ã«åŸºã¥ã„ã¦ãƒ©ãƒ™ãƒ«ã‚’æ›´æ–°ã™ã‚‹ã€‚
        generateDynamicInputs();
        updateLabelsFromInputs(); 

        // æ¢¯å­ã®æ§‹é€ ã‚’å†ç”Ÿæˆ
        generateRungs();
        drawLadder();
    }

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ã‚’éè¡¨ç¤ºã«ã—ã€è»Œè·¡ã‚’ã‚¯ãƒªã‚¢ã—ã¦å†æç”»ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
    function hideMessageBoxAndClearPath() {
        cancelAnimation(); 
        
        if (messageBox.classList.contains('hidden')) return; 
        
        messageBox.classList.add('hidden');
        
        pathCoordinates = [];
        drawLadder();
    }

    // åˆæœŸåŒ–å‡¦ç†
    document.addEventListener('DOMContentLoaded', () => {
        // setupCanvasã¯DOMã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å¾Œã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’å–å¾—
        generateDynamicInputs();
        updateLadder(); // åˆæœŸæç”»
        setupCanvas(); 
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
        columnCountInput.addEventListener('change', updateLadder); // å¤‰æ›´æ™‚ã«å³åº§ã«å†æç”»ã¨å…¥åŠ›æ›´æ–°
        generateButton.addEventListener('click', updateLadder); 
        
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                e.preventDefault(); 
                // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’æ¨¡æ“¬
                handleCanvasClick({
                    touches: e.touches,
                    preventDefault: () => e.preventDefault(),
                    target: e.target
                });
            }
        });

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹è‡ªä½“ã«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ ï¼ˆçµæœè¡¨ç¤ºã‚’é–‰ã˜ã‚‹ï¼‰
        messageBox.addEventListener('click', hideMessageBoxAndClearPath);
        
        messageBox.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            hideMessageBoxAndClearPath();
        });
        
        window.addEventListener('resize', setupCanvas); 
    });

</script>
</body>
</html>
