<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Web ノート</title>
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body { 
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none; 
            background-color: #f3f4f6;
        }

        body {
            display: flex;
            flex-direction: column;
        }

        header {
            flex-shrink: 0;
            z-index: 100;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            touch-action: pan-y;
        }

        .header-grid {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            width: 100%;
        }

        #canvas-container {
            flex-grow: 1;
            overflow: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            gap: 20px;
            touch-action: none; 
            -webkit-overflow-scrolling: touch;
        }

        .canvas-wrapper {
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            background-color: white;
            flex-shrink: 0;
        }

        .tool-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s;
            cursor: pointer;
        }
        .tool-btn:hover { background-color: #e5e7eb; }
        .tool-btn.active { background-color: #3b82f6; color: white; }
        
        footer {
            flex-shrink: 0;
            z-index: 100;
            background-color: white;
            padding: 8px;
            border-top: 1px solid #e5e7eb;
        }

        @media (max-width: 768px) {
            .header-grid {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 8px;
            }
        }
    </style>
</head>
<body>

    <header class="border-b p-3">
        <div class="header-grid gap-4">
            <!-- Left: File Operations -->
            <div class="flex items-center gap-2 justify-start">
                <h1 class="font-bold text-lg text-gray-800 hidden lg:block mr-2">Web ノート</h1>
                <input type="file" id="upload-pdf" accept="application/pdf" class="hidden">
                <label for="upload-pdf" class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-2 rounded-lg cursor-pointer transition flex items-center gap-2 border text-xs whitespace-nowrap">
                    <span>PDFをアップロード</span>
                </label>
                <button onclick="addNewPage()" class="bg-green-100 hover:bg-green-200 text-green-700 px-3 py-2 rounded-lg cursor-pointer transition flex items-center gap-2 border text-xs whitespace-nowrap">
                    <span>ページ追加</span>
                </button>
            </div>

            <!-- Center: Tool Bar -->
            <div class="flex items-center gap-1 bg-gray-50 p-1 rounded-xl border flex-nowrap shadow-sm">
                <button onclick="setMode('select')" id="btn-select" class="tool-btn active" title="選択">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 3 7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="m13 13 6 6"/></svg>
                </button>
                <button onclick="setMode('draw')" id="btn-draw" class="tool-btn" title="ペン">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="m2 2 5 5"/><path d="m11 11 5 5"/></svg>
                </button>
                <button onclick="setMode('highlighter')" id="btn-highlighter" class="tool-btn" title="蛍光ペン">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 11-6 6v3h9l3-3"/><path d="m22 12-4.6 4.6a2 2 0 0 1-2.8 0l-5.2-5.2a2 2 0 0 1 0-2.8L14 4"/><path d="m5 15 3 3"/></svg>
                </button>
                <button onclick="setMode('erase')" id="btn-erase" class="tool-btn" title="消しゴム">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></svg>
                </button>
                <button onclick="addText()" id="btn-text" class="tool-btn" title="テキスト">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg>
                </button>
                <div class="h-6 w-[1px] bg-gray-300 mx-1"></div>
                <button onclick="undo()" class="tool-btn" title="元に戻す">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>
                </button>
                <div class="h-6 w-[1px] bg-gray-300 mx-1"></div>
                <button onclick="zoomOut()" class="tool-btn" title="縮小">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg>
                </button>
                <span id="zoom-level" class="text-xs font-mono w-10 text-center">100%</span>
                <button onclick="zoomIn()" class="tool-btn" title="拡大">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg>
                </button>
                <div class="h-6 w-[1px] bg-gray-300 mx-1"></div>
                <input type="color" id="color-picker" value="#000000" class="w-6 h-6 cursor-pointer rounded overflow-hidden p-0 border-none">
                <select id="brush-size" class="bg-transparent text-xs border-none focus:ring-0">
                    <option value="2">細</option>
                    <option value="5" selected>中</option>
                    <option value="12">太</option>
                </select>
            </div>

            <!-- Right: Save and Reset -->
            <div class="flex items-center gap-2 justify-end">
                <button onclick="clearAll()" class="text-red-500 hover:bg-red-50 px-3 py-2 rounded-lg text-xs font-bold border border-red-200">全クリア</button>
                <button onclick="downloadPDF()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg font-bold shadow-md transition text-xs">保存</button>
            </div>
        </div>
    </header>

    <main id="canvas-container">
        <!-- Canvases -->
    </main>

    <footer>
        <div class="max-w-4xl mx-auto flex justify-between items-center px-4">
            <p id="page-counter" class="text-gray-700 font-bold text-xs">ページ: 1 / 1</p>
        </div>
    </footer>

    <script>
        let pages = [];
        let currentMode = 'select';
        let canvasScale = 1.0;
        
        let baseWidth = 595; 
        let baseHeight = 842; 
        let lastDistance = null;
        let startScale = 1.0;

        function initApp() {
            addNewPage();
            setupGestures();

            window.addEventListener('wheel', (e) => {
                if (e.ctrlKey) {
                    e.preventDefault();
                    if (e.deltaY < 0) zoomIn();
                    else zoomOut();
                }
            }, { passive: false });

            const container = document.getElementById('canvas-container');
            container.addEventListener('scroll', updatePageCounter);

            document.getElementById('color-picker').addEventListener('input', () => pages.forEach(updatePageMode));
            document.getElementById('brush-size').addEventListener('change', () => pages.forEach(updatePageMode));
        }

        function setupGestures() {
            const container = document.getElementById('canvas-container');
            let startY = 0;
            let startScrollTop = 0;

            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    lastDistance = getDistance(e.touches);
                    startScale = canvasScale;
                } else if (e.touches.length === 1) {
                    startY = e.touches[0].pageY;
                    startScrollTop = container.scrollTop;
                }
            }, { passive: false });

            container.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 2 && lastDistance) {
                    const newDistance = getDistance(e.touches);
                    const ratio = newDistance / lastDistance;
                    let newScale = startScale * ratio;
                    if (newScale >= 0.3 && newScale <= 4.0) {
                        canvasScale = newScale;
                        updateAllCanvasSizes();
                    }
                } else if (e.touches.length === 1 && currentMode === 'select') {
                    const deltaY = startY - e.touches[0].pageY;
                    container.scrollTop = startScrollTop + deltaY;
                }
            }, { passive: false });

            container.addEventListener('touchend', () => {
                lastDistance = null;
            });
        }

        function getDistance(touches) {
            return Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY);
        }

        function createPageCanvas() {
            const container = document.getElementById('canvas-container');
            const wrapper = document.createElement('div');
            wrapper.className = 'canvas-wrapper';
            
            const canvasEl = document.createElement('canvas');
            wrapper.appendChild(canvasEl);
            container.appendChild(wrapper);

            const fCanvas = new fabric.Canvas(canvasEl, {
                isDrawingMode: false,
                undoStack: []
            });

            const removeObjectWithUndo = (target) => {
                if (target && !target._isBackground) {
                    target._isRemovedAction = true; 
                    fCanvas.remove(target);
                    fCanvas.undoStack.push({ type: 'remove', obj: target });
                    fCanvas.renderAll();
                }
            };

            fCanvas.on('mouse:move', (options) => {
                if (currentMode === 'erase' && options.e.buttons === 1) {
                    removeObjectWithUndo(fCanvas.findTarget(options.e));
                }
            });

            fCanvas.on('mouse:down', (options) => {
                if (currentMode === 'erase') {
                    removeObjectWithUndo(fCanvas.findTarget(options.e));
                }
            });

            fCanvas.on('object:added', (e) => {
                if (!e.target._isHistoryAction) {
                    fCanvas.undoStack.push({ type: 'add', obj: e.target });
                }
            });

            pages.push(fCanvas);
            return fCanvas;
        }

        function addNewPage(bgImage = null) {
            const fCanvas = createPageCanvas();
            
            fCanvas.setDimensions({
                width: baseWidth * canvasScale,
                height: baseHeight * canvasScale
            });
            fCanvas.setZoom(canvasScale);

            if (bgImage) {
                fabric.Image.fromURL(bgImage, function(img) {
                    img.set({
                        scaleX: (baseWidth * canvasScale) / img.width / canvasScale,
                        scaleY: (baseHeight * canvasScale) / img.height / canvasScale,
                        originX: 'left', originY: 'top',
                        selectable: false, evented: false,
                        _isBackground: true 
                    });
                    fCanvas.setBackgroundImage(img, fCanvas.renderAll.bind(fCanvas));
                });
            } else {
                fCanvas.backgroundColor = '#ffffff';
                for(let i = 50; i < baseHeight; i += 30) {
                    const line = new fabric.Line([0, i, baseWidth, i], {
                        stroke: '#f1f5f9',
                        selectable: false,
                        evented: false,
                        _isBackground: true 
                    });
                    fCanvas.add(line);
                }
                fCanvas.renderAll();
            }

            updatePageMode(fCanvas);
            updatePageCounter();
        }

        function updateAllCanvasSizes() {
            pages.forEach(fCanvas => {
                fCanvas.setDimensions({
                    width: baseWidth * canvasScale,
                    height: baseHeight * canvasScale
                });
                fCanvas.setZoom(canvasScale);
                fCanvas.renderAll();
            });
            document.getElementById('zoom-level').textContent = Math.round(canvasScale * 100) + '%';
        }

        function updatePageCounter() {
            const container = document.getElementById('canvas-container');
            const scrollTop = container.scrollTop;
            const pageH = baseHeight * canvasScale + 20; 
            const currentPage = Math.min(pages.length, Math.floor((scrollTop + (pageH / 2)) / pageH) + 1);
            
            document.getElementById('page-counter').textContent = `ページ: ${currentPage || 1} / ${pages.length}`;
        }

        function zoomIn() {
            canvasScale = Math.min(4.0, canvasScale + 0.1);
            updateAllCanvasSizes();
            updatePageCounter();
        }

        function zoomOut() {
            canvasScale = Math.max(0.3, canvasScale - 0.1);
            updateAllCanvasSizes();
            updatePageCounter();
        }

        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`btn-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');
            
            const colorPicker = document.getElementById('color-picker');
            // Reset color for pen, text
            if (mode === 'draw' || mode === 'text') {
                colorPicker.value = '#000000';
            } else if (mode === 'highlighter') {
                colorPicker.value = '#ffff00';
            }

            pages.forEach(fCanvas => {
                fCanvas.selection = (mode === 'select');
                fCanvas.forEachObject(obj => {
                    if (!obj._isBackground) {
                        obj.selectable = (mode === 'select');
                        obj.evented = (mode === 'select' || mode === 'erase');
                    }
                });
                updatePageMode(fCanvas);
            });
        }

        function updatePageMode(fCanvas) {
            const color = document.getElementById('color-picker').value;
            const size = parseInt(document.getElementById('brush-size').value);

            if (currentMode === 'draw') {
                fCanvas.isDrawingMode = true;
                fCanvas.freeDrawingBrush = new fabric.PencilBrush(fCanvas);
                fCanvas.freeDrawingBrush.width = size;
                fCanvas.freeDrawingBrush.color = color;
            } else if (currentMode === 'highlighter') {
                fCanvas.isDrawingMode = true;
                fCanvas.freeDrawingBrush = new fabric.PencilBrush(fCanvas);
                fCanvas.freeDrawingBrush.width = size * 4;
                const r = parseInt(color.slice(1, 3), 16), g = parseInt(color.slice(3, 5), 16), b = parseInt(color.slice(5, 7), 16);
                fCanvas.freeDrawingBrush.color = `rgba(${r}, ${g}, ${b}, 0.3)`;
            } else {
                fCanvas.isDrawingMode = false;
            }
        }

        function addText() {
            setMode('text');
            const container = document.getElementById('canvas-container');
            const scrollTop = container.scrollTop;
            const pageH = baseHeight * canvasScale + 20;
            const idx = Math.min(pages.length - 1, Math.floor((scrollTop + (pageH / 2)) / pageH));
            const target = pages[idx];

            const text = new fabric.IText('テキスト入力', {
                left: 100,
                top: 100,
                fontFamily: 'sans-serif',
                fontSize: 24,
                fill: document.getElementById('color-picker').value,
                selectable: true
            });
            target.add(text);
            target.setActiveObject(text);
            target.renderAll();
            
            // Text selection automatically switches back to select mode for interaction
            setMode('select');
        }

        function undo() {
            pages.forEach(fCanvas => {
                if (fCanvas.undoStack.length > 0) {
                    const lastAction = fCanvas.undoStack.pop();
                    if (lastAction.type === 'add') {
                        lastAction.obj._isHistoryAction = true;
                        fCanvas.remove(lastAction.obj);
                    } else if (lastAction.type === 'remove') {
                        lastAction.obj._isHistoryAction = true;
                        fCanvas.add(lastAction.obj);
                    }
                    fCanvas.renderAll();
                }
            });
        }

        function clearAll() {
            const modal = confirm("ノートを初期化しますか？\n描画内容と追加したページは削除されます。");
            if (modal) {
                const container = document.getElementById('canvas-container');
                container.innerHTML = '';
                pages = [];
                addNewPage();
                setMode('select');
                container.scrollTop = 0;
            }
        }

        async function downloadPDF() {
            const { PDFDocument } = PDFLib;
            const pdfDoc = await PDFDocument.create();
            for (const fCanvas of pages) {
                const oldZoom = fCanvas.getZoom();
                fCanvas.setZoom(1.0);
                fCanvas.setDimensions({ width: baseWidth, height: baseHeight });
                const dataUrl = fCanvas.toDataURL({ format: 'png', multiplier: 2 });
                
                fCanvas.setZoom(oldZoom);
                fCanvas.setDimensions({ width: baseWidth * oldZoom, height: baseHeight * oldZoom });

                const pngImage = await pdfDoc.embedPng(dataUrl);
                const page = pdfDoc.addPage([baseWidth, baseHeight]);
                page.drawImage(pngImage, { x: 0, y: 0, width: baseWidth, height: baseHeight });
            }
            const pdfBytes = await pdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'notebook.pdf';
            link.click();
        }

        window.onload = initApp;
    </script>
</body>
</html>